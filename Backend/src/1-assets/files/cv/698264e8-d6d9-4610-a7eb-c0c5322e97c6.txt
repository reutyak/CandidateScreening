לאחר שלמדנו כיצד מעריכים את משך ה-timeout בפרוטוקול TCP,
בואו נחזור ונראה כיצד TCP מיישם אמינות .
נזכיר שראינו שלושה פרוטוקולים: "Stop and Wait",
"Go Back N" ו"Selective Repeat" המיישמים אמינות.
נראה כי TCP הוא שילוב של "Go Back N" ו"Selective Repeat".
קודם כל, TCP מיישמת שירות "Reliable Data Transfer" (העברת נתונים אמינה), או RDT,
מעל שכבת הרשת.
זה נעשה על ידי שליחת הסגמנטים באותו "צינור" (pipelining), ושימוש ב- ACKs מצטברים
וטיימר יחיד, בדיוק כמו ב- "Go Back N". לגבי השידור החוזר, שעשוי לנבוע מ-
Timeouts שנגמרו או כפילויות של ACK, נדון בזה מאוחר יותר
לעת עתה, נניח שימוש ב- TCP מופשט
שיבטל את ה- ACK הכפולים ולא תהיה לו בקרת זרימה או בקרת עומס.
כעת ננסה להבין כיצד TCP מיישמת את האמינות שלה.
נראה שזה שילוב של "Go Back N" ו"Selective Repeat".
בואו נסתכל על שלושה אירועים שיכולים לקרות בצד המקבל.
האירוע הראשון מתרחש עם קבלת נתונים משכבת ​​האפליקציה,
האירוע השני מתרחש כשנגמר הtimeout. מה על השולח לעשות
במקרה של timeout? והאירוע השלישי הוא ברגע
שההודעה מגיעה לקצה המקבל. מה השולח צריך לעשות אז?
בואו נסתכל על האירוע הראשון: נתונים מתקבלים משכבת ​​האפליקציה.
אנו מקבלים סגמנט עם מספר סידורי. המספר הסידורי מייצג
את מספר הבית הראשון בתוך זרם הבתים
שנשלח משכבת ​​האפליקציה. אם הטיימר עדיין לא פועל, אנו מתחילים אותו,
וtimeout מחושב בהתאם למרווח הזמן הקצוב.
במקרה של timeout (כלומר נגמר פסק הזמן שהוקצב להודעה), יש שידור חוזר של
הסגמנט שגרם לtimeout והטיימר מופעל מחדש.
במקרה השלישי, כאשר מתקבל אישור (ACK),
אנו בודקים אם ACK זה מיועד לסגמנט שטרם אושר.
אם כן, אנו מסמנים את הסגמנט הזה כ-"נשלח"
אך אם עדיין יש סגמנטים שלא קיבלו אישור (ACK) נמשיך להריץ את הטיימר.
אז זה מה שקורה במקרה של השולח ב- TCP.
אז בואו נסתכל כיצד הצד של השולח מיישם אמינות.
עברנו על שלושה אירועים עיקריים, שהם קבלת נתונים
משכבת ​​האפליקציה, timeout וקבלת ACK.
חוץ מזה, יש לנו אתחול.
כאשר זה קורה, ה- NextSeqNum (מספר סידורי הבא) מאותחל כ- InitialSeqNum (מספר סידורי ראשוני),
וה- SendBase, תחילת החלון, מאותחל ל- InitialSeqNum.
לאחר שנסיים את שלב האתחול, האירועים הבאים קורים.
הנתונים מתקבלים משכבת ​​האפליקציה, נוצר סגמנט
עם המספר הסידורי NextSeqNum המועבר לשכבת ה- IP.
לאחר מכן, NextSeqNum מתעדכן,
וזה יהיה הערך של NextSeqNum שאנו שולחים,
בתוספת אורך הנתונים שהכנסנו לתוכו. אם לא הפעלנו את הטיימר לפאקטה,
אזי נפעיל אותו עם ערך הtimeout אותו נוכל לנחש.
במקרה של timeout, אנו שולחים שוב את הסגמנט עם המספר הסידורי הקטן ביותר
שעדיין לא קיבל אישור קבלה (ACK) ואנו מפעילים מחדש את הטיימר.
במקרה של קבלת אישור (ACK), אנו מחזירים את ערך המספר הסידורי שלו, Y.
אם Y גדול מה- SendBase, החלון ההתחלתי,
אנו מעדכנים את SendBase כך שיהיה שווה ל- Y, כלומר כל הקטעים עד Y התקבלו.
נזכיר כי TCP שולח את הערך הצפוי הבא כמספר סידורי של ה-ACK.
אם עדיין קיים סגמנט שלא קיבל אישור קבלה, הטיימר ממשיך.
אחרת, הטיימר מושהה.
זהו סיכום של מכונת המצבים של שולח TCP
הבה נבחן כעת שני תרחישים של שידורים חוזרים.
בשני המקרים, יש לנו שתי נקודות קצה, מארח A ומארח B.
במקרה הראשון, מארח A שולח סגמנט עם מספר סידורי 92,
אורך הנתונים הוא 8 בתים מזרם הבתים של שכבת האפליקציה.
מכיוון שהכל התקבל בהצלחה, בפעם הבאה מארח B מצפה לראות את הקטע
עם מספר סידורי 100, מאותו זרם בתים
שמגיע משכבת ​​האפליקציה. אבל האישור עדיין לא
הגיעה ותם הtimeout, ולכן מארח A שולח מחדש את אותו סגמנט
עם מספר סידורי של 92 ואורך של 8 בתים.
הפעם האישור מתקבל, והתקשורת נמשכת כרגיל.
המקרה השני הוא מקרה של timeout, עם ערך timeout קטן מדי.
נראה מה יקרה במקרה זה. שוב, SendBase מוגדר ל- 92 sp,
לסגמנט שנשלח יש מספר סידורי 92, ו -8 בתים של נתונים
הקטע התקבל ואושר בהצלחה,
אנו רואים שמארח B שלח אישור ושבפעם הבאה הוא מצפה לראות
את הסגמנט שמתחיל מהבית ה -100 של זרם הבתים של שכבת האפליקציה,
אך אישור זה מגיע רק לאחר תום ה-timeout.
בינתיים, המארח A מקבל אירוע timeout,
וכתוצאה מכך, שולח שוב את הפאקטה עם אותו מספר סידורי 92
ואת 8 בתים של זרם בתים משכבת ​​האפליקציה שוב.
האישור הבא מתקבל, והתקשורת עשויה להימשך,
אך שימו לב לעובדה שעקב timeout קצר מידי
יש שתי שליחות מיותרות.
בואו נסתכל על תרחיש אחר של שליחה חוזרת. זהו המקרה של ה- ACK המצטבר.
שוב יש לנו מארח A ומארח B. מארח A שולח את הקטע עם SeqNum 92
ו -8 בתים של מידע משכבת ​​האפליקציה.
וקטע זה מתקבל בהצלחה על ידי מארח B
המגיב למארח A שהוא מצפה לראות את הסגמנט שמתחיל בבית  ה-100 בפעם הבאה.
אבל ה- ACK הזה נופל.
בינתיים, מארח A שולח חבילה נוספת, עם SeqNum 100, ו -20 בתים של נתונים.
המארח B שולח שוב ACK,
ואומר למארח A שהקטע הבא הצפוי צריך להתחיל ב
-120 בתים, והפעם ACK מגיע למארח A
עכשיו, כשהוא מגיע בהצלחה, מה שבאמת קורה
הוא שמארח A שולח כעת קטע עם מספר סידורי
של 120, כי כל הבתים עד 119 הגיעו בהצלחה,
וזה בדיוק מה שהצד של השולח מבין
מהאישור שהגיע עבור הסגמנט השני.
המשמעות היא ש- TCP מצליח להתגבר על אובדן הACK ללא
כל פגיעה במספר הפאקטות, או במספר הסגמנטים שנשלחו ממארח ​​A.
בואו נסכם את האירועים והפעולות שננקטו בצד המקבל של TCP.
ברגע שהסגמנט מגיע בסדר הצפוי,
עם המספר הסידורי הצפוי מה שקורה בפועל הוא
שהצד המקבל יחכה עד 500ms להגעת הסגמנט הבא.
אם הוא לא מגיע, נשלח ACK.
זה נעשה כדי לצמצם את מספר האישורים הנשלחים.
האירוע הבא הוא הגעת הסגמנט בסדר הצפוי,
עם המספר הסידורי הצפוי. אך לסגמנט אחר יש אישור ממתין שטרם נשלח,
במקרה זה הצד המקבל ב- TCP פשוט שולח ACK מצטבר
לשני הקטעים שהגיעו בסדר הצפוי.
זה נעשה על מנת לקדם את חלון השולח בצד השולח.
האירוע הבא הוא סגמנט שמגיע לא לפי הסדר עם מספר סידורי גבוה מהצפוי,
ובכך יוצר סוג של פער.
ACK כפול נשלח מייד עם המספר הסידורי הצפוי (כדי להשלים את הפער).
ולבסוף, מגיע קטע הממלא את הפער.
במקרה זה ה-ACK נשלח באופן מיידי
מה שנותן אפשרות להזיז את החלון בקצה השולח.
בואו נדבר על אופטימיזציה שנותנת לנו את האפשרות לא לחכות עד
שיקרה אירוע timeout של TCP. זה נעשה על מנת לשפר את זמן התגובה
של TCP לאובדן סגמנטים. אז מה באמת קורה?
ההצעה היא לגלות אובדן סגמנט באמצעות שליחת הודעות ACK כפולות.
כעת, השולח שולח מספר סגמנטים בזה אחר זה.
אם סגמנט הלך לאיבוד, בוודאי היו הודעות ACK כפולות רבות.
נזכיר כי הקצה המקבל מגיב באישור ACK,
עם מספר הבית שהוא מצפה לראות בפעם הבאה.
מה קורה? שידור חוזר מהיר של TCP
הוא החלטה שהתקבלה על ידי השולח. אם השולח מקבל שלוש הודעות ACK
על אותו מספר סידורי, הוא נקרא ACK כפול משולש,
כך שאנו יכולים להניח עם אחוז ההסתברות גבוה שנאבדה הפאקטה.
אז השולח שולח את הפאקטה שוב.
בואו נסתכל על דוגמה של שידור חוזר מהיר.
מארח A שולח סגמנט עם מספר סידורי של 92 הכולל 8 בתים של נתונים בפנים.
ומיד לאחר מכן, את הסגמנט הבא עם המספר הסידורי העוקב 100.
קטע עם מספר סידורי 92 מגיע למארח B ומאושר,
אבל הקטע עם המספר הסידורי 100 הולך לאיבוד בדרך למארח B
לאחר שנשלח הסגמנט עם מספר סידורי 100,
סגמנטים נוספים נשלחים. אנחנו מדברים על פרוטוקול TCP.
עכשיו אנחנו רואים שבכל פעם שמארח B יגיב עם אישור 100,
ואנו זוכרים שב- TCP הוא בעצם מגיב עם המספר
שהוא מצפה לראות בפעם הבאה מכיוון שהסגמנט עם
המספר הסידורי 100 לא הגיע הוא שולח ACK 100, ACK 100 , ACK 100,
ואחרי שלושה ACKS כפולים,
אנחנו רואים שקיבלנו ACK כפול שלוש פעמים.
השולח מתחיל להבין שבטח היה אובדן סגמנט
וזה קורה מיד לפני פסק הזמן, כלומר ניתן לראות שהתגובה כאן מהירה יותר,
והיא שולחת מחדש את הסגמנט עם המספר הסידורי 100.
שזה מהותו של השידור החוזר המהיר, לא לחכות לtimeout מלא,
ולהשתמש ב- ACK הכפול המשולש כטריגר לשליחת הודעות נוספות.
אתה עשוי לתהות מדוע שלושה ACK כפולים, והסיבה היא אמפירית.
התברר שאם יש שלושה ACK כפולים,
הסיבה לכך היא שהפאקטה נפלה, ולא הייתה הזמנה מחדש בדרך.